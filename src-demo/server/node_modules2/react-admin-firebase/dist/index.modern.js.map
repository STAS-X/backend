{"version":3,"file":"index.modern.js","sources":["../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/logger.ts","../src/misc/logger/firestore-logger.ts","../src/misc/dispatcher.ts","../src/misc/translate-from-firestore.ts","../src/misc/document-parser.ts","../src/misc/internal.models.ts","../src/misc/pathHelper.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/misc/firebase-models.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/translate-to-firestore.ts","../src/misc/metadata-parser.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/DataProvider.ts","../src/misc/status-code-translator.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts","../src/providers/AuthProvider.ts"],"sourcesContent":["import { get, isEmpty } from 'lodash';\nimport { getFieldReferences, SearchObj } from './objectFlatten';\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: 'asc' | 'desc'\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = get(a, field);\n    const rawB = get(b, field);\n    const isAsc = dir === \"asc\";\n\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    if (isNumberField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\n    if (isStringField) {\n      const aParsed = rawA.toLowerCase();\n      const bParsed = rawB.toLowerCase();\n      return basicSort(aParsed, bParsed, isAsc);\n    }\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\n    if (isDateField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    return basicSort(!!rawA, !!rawB, isAsc);\n  });\n}\n\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\n  if (aValue > bValue) {\n    return isAsc ? 1 : -1;\n  }\n  if (aValue < bValue) {\n    return isAsc ? -1 : 1;\n  }\n  return 0;\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields?: { [field: string]: string | number | boolean | null }\n): Array<{}> {\n  if (!searchFields || isEmpty(searchFields)) {\n    return data;\n  }\n  const searchObjs: SearchObj[] = [];\n  Object.keys(searchFields).map((fieldName) => {\n    const fieldValue = searchFields[fieldName];\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\n    searchObjs.push(...getSubObjects);\n  });\n  const filtered = data.filter((row) =>\n    searchObjs.reduce((acc, cur) => {\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\n      return res && acc;\n    }, true as boolean)\n  );\n  return filtered;\n}\n\nexport function doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: any\n): boolean {\n  const searchThis = get(row, searchField);\n  const bothAreFalsey = !searchThis && !searchValue;\n  if (bothAreFalsey) {\n    return true;\n  }\n  const nothingToSearch = !searchThis;\n  if (nothingToSearch) {\n    return false;\n  }\n  const isStringSearch = typeof searchValue === 'string';\n  if (isStringSearch) {\n    return searchThis\n      .toString()\n      .toLowerCase()\n      .includes(searchValue.toLowerCase());\n  }\n  const isBooleanOrNumber =\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\n  if (isBooleanOrNumber) {\n    return searchThis === searchValue;\n  }\n  const isArraySearch = Array.isArray(searchValue);\n  if (isArraySearch) {\n    return searchValue.includes(searchThis);\n  }\n  return false;\n}\n","type SearchValues = {} | number | string | boolean | null ;\ntype SearchValue = SearchValues | SearchValue[];\n\nexport interface SearchObj {\n  searchField: string;\n  searchValue: SearchValue;\n}\nexport function getFieldReferences(\n  fieldName: string,\n  value: {} | SearchValue\n): SearchObj[] {\n  const isFalsy = !value;\n  const isSimple = isFalsy ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean';\n\n  if (isSimple) {\n    return [\n      {\n        searchField: fieldName,\n        searchValue: value as SearchValue,\n      },\n    ];\n  }\n  const tree = {} as Record<string, SearchValue>;\n  tree[fieldName] = value;\n  return objectFlatten(tree);\n}\n\nexport function objectFlatten(tree: {}): SearchObj[] {\n  var leaves: SearchObj[] = [];\n  var recursivelyWalk = function (obj: any, path: string | null) {\n    path = path || \"\";\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const objVal = obj && obj[key];\n        const currentPath = !!path ? path + \".\" + key : key;\n        const isWalkable =\n          typeof objVal === 'object' || objVal instanceof Array;\n        if (isWalkable) {\n          recursivelyWalk(objVal, currentPath);\n        } else {\n          leaves.push({ searchField: currentPath, searchValue: objVal });\n        }\n      }\n    }\n  };\n  recursivelyWalk(tree, null);\n  return leaves;\n}\n","type LogFn = (...args: any) => void;\n\nexport const LogNoOp: LogFn = (...args: any) => null;\n\nexport class LoggerBase {\n  constructor(private title: string, private cacheEnabledKey: string) {}\n\n  private isEnabled() {\n    return !!localStorage.getItem(this.cacheEnabledKey);\n  }\n\n  SetEnabled(isEnabled: boolean) {\n    if (isEnabled) {\n      localStorage.setItem(this.cacheEnabledKey, 'true');\n    } else {\n      localStorage.removeItem(this.cacheEnabledKey);\n    }\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.log.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.warn.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n","import { LoggerBase } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\n\nexport const log = logger.log;\nexport const logError = logger.error;\nexport const logWarn = logger.warn;\n","import { RAFirebaseOptions } from 'providers/options';\nimport { LogNoOp, LoggerBase } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\n\nconst KEY_SINGLE = 'firecosts-single-reads';\n\nexport interface IFirestoreLogger {\n  logDocument: (count: number) => Function;\n  SetEnabled: (isEnabled: boolean) => void;\n  ResetCount: (shouldReset: boolean) => void;\n}\n\nexport function MakeFirestoreLogger(\n  options: RAFirebaseOptions\n): IFirestoreLogger {\n  function notEnabled() {\n    return !options?.lazyLoading?.enabled;\n  }\n\n  function incrementRead(incrementBy = 1) {\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\n    const currentCount = parseInt(currentCountRaw) || 0;\n    const incremented = currentCount + incrementBy;\n    localStorage.setItem(KEY_SINGLE, incremented + '');\n    return incremented;\n  }\n  function clearCache() {\n    localStorage.removeItem(KEY_SINGLE);\n  }\n  return {\n    SetEnabled(isEnabled: boolean) {\n      logger.SetEnabled(isEnabled);\n    },\n    ResetCount(shouldReset: boolean) {\n      shouldReset && clearCache()\n    },\n    logDocument(docCount: number) {\n      if (notEnabled()) {\n        return LogNoOp;\n      }\n      const count = incrementRead(docCount);\n      const suffix = `+${docCount} (session total=${count} documents read)`;\n      const boundLogFn: (...args: any) => void = logger.log.bind(\n        console,\n        suffix\n      );\n      return boundLogFn;\n    },\n  };\n}\n","import { log } from './logger';\n\nexport type DispatchEvent =\n\t'FILE_UPLOAD_WILL_START' |\n\t'FILE_UPLOAD_PROGRESS' |\n\t'FILE_UPLOAD_PAUSED' |\n\t'FILE_UPLOAD_RUNNING' |\n\t'FILE_UPLOAD_CANCELED' |\n\t'FILE_UPLOAD_COMPLETE' |\n\t'FILE_SAVED';\n\nexport function dispatch(\n\teventName: DispatchEvent,\n\tfileName: string,\n\tdata?: any,\n): void {\n\tconst eventMonitor = document.getElementById('eventMonitor');\n\tif (!eventMonitor) {\n\t\tlog(`eventMonitor not found to dispatch event ${eventName} for ${fileName}`);\n\t\treturn;\n\t}\n\tconst eventData = { fileName, data };\n\tlet event = new CustomEvent(eventName, { detail: eventData });\n\teventMonitor.dispatchEvent(event);\n};","import { set, has } from \"lodash\";\nimport { IFirebaseWrapper } from \"providers/database\";\nimport { REF_INDENTIFIER } from \"./internal.models\";\nimport { logError } from \"./logger\";\nimport { FireStoreDocumentRef } from \"./firebase-models\";\n\nexport interface RefDocFound {\n  fieldPath: string;\n  refDocPath: string;\n}\n\nexport interface FromFirestoreResult {\n  parsedDoc: any;\n  refdocs: RefDocFound[];\n}\n\nexport function translateDocFromFirestore(obj: any) {\n  const isObject = !!obj && typeof obj === \"object\";\n  const result: FromFirestoreResult = {\n    parsedDoc: {},\n    refdocs: [],\n  };\n  if (!isObject) {\n    return result;\n  }\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    obj[key] = recusivelyCheckObjectValue(value, key, result);\n  });\n  result.parsedDoc = obj;\n  return result;\n}\n\nexport function recusivelyCheckObjectValue(\n  input: any,\n  fieldPath: string,\n  result: FromFirestoreResult\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== \"object\";\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === \"function\";\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as any[]).map((value, index) =>\n      recusivelyCheckObjectValue(value, `${fieldPath}.${index}`, result)\n    );\n  }\n  const isDocumentReference = isInputADocReference(input);\n  if (isDocumentReference) {\n    const ref = input as FireStoreDocumentRef;\n    result.refdocs.push({ fieldPath: fieldPath, refDocPath: ref.path });\n    return ref.id;\n  }\n  const isObject = typeof input === \"object\";\n  if (isObject) {\n    Object.keys(input).map((key) => {\n      const value = input[key];\n      input[key] = recusivelyCheckObjectValue(value, key, result);\n    });\n    return input;\n  }\n  return input;\n}\n\nfunction isInputADocReference(input: any): boolean {\n  const isDocumentReference = typeof input.id === \"string\" &&\n    typeof input.firestore === \"object\" &&\n    typeof input.parent === \"object\" &&\n    typeof input.path === \"string\";\n  return isDocumentReference;\n}\n\nexport function applyRefDocs(\n  doc: any,\n  refDocs: RefDocFound[],\n) {\n  refDocs.map((d) => {\n    set(doc, REF_INDENTIFIER + d.fieldPath, d.refDocPath);\n  });\n  return doc;\n}\n\nexport const recursivelyMapStorageUrls = async (\n  fireWrapper: IFirebaseWrapper,\n  fieldValue: any\n): Promise<any> => {\n  const isPrimitive = !fieldValue || typeof fieldValue !== 'object';\n  if (isPrimitive) {\n    return fieldValue\n  }\n  const isFileField = has(fieldValue, 'src');\n  if (isFileField) {\n    try {\n      const src = await fireWrapper\n        .storage()\n        .ref(fieldValue.src)\n        .getDownloadURL();\n      return {\n        ...fieldValue,\n        src,\n      };\n    } catch (error) {\n      logError(`Error when getting download URL`, {\n        error,\n      });\n      return fieldValue;\n    }\n  }\n  const isArray = Array.isArray(fieldValue);\n  if (isArray) {\n    return Promise.all(\n      (fieldValue as any[]).map(async (value, index) => {\n        fieldValue[index] = await recursivelyMapStorageUrls(fireWrapper, value);\n      })\n    );\n  }\n  const isDocumentReference = isInputADocReference(fieldValue);\n  if (isDocumentReference) {\n    return fieldValue;\n  }\n  const isObject = !isArray && typeof fieldValue === \"object\";\n  if (isObject) {\n    return Promise.all(\n      Object.keys(fieldValue).map(async (key) => {\n        const value = fieldValue[key];\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\n      })\n    );\n  }\n};\n","import { FireStoreQueryDocumentSnapshot, FireStoreDocumentSnapshot } from \"./firebase-models\";\nimport { logWarn } from \"./logger\";\nimport { applyRefDocs, translateDocFromFirestore } from \"./translate-from-firestore\";\nimport * as ra from './react-admin-models';\n\nexport function parseFireStoreDocument<T extends ra.Record>(doc: FireStoreQueryDocumentSnapshot | FireStoreDocumentSnapshot | undefined): T {\n  if (!doc) {\n    logWarn('parseFireStoreDocument: no doc', { doc });\n    return {} as T;\n  }\n  const data = doc.data();\n  const result = translateDocFromFirestore(data);\n  const dataWithRefs = applyRefDocs(result.parsedDoc, result.refdocs);\n  // React Admin requires an id field on every document,\n  // So we can just using the firestore document id\n  return { id: doc.id, ...dataWithRefs } as T;\n}\n","export const REF_INDENTIFIER = \"___REF_FULLPATH_\";\n\nexport interface ParsedRefDoc {\n  ___refpath: string;\n  ___refid: string;\n}\n","import path from \"path-browserify\";\n\nexport function getAbsolutePath(\n  rootRef: undefined | string | (() => string),\n  relativePath: string | null\n): string {\n  if (!rootRef) {\n    return relativePath+'';\n  }\n  if (!relativePath) {\n    throw new Error(\n      \"Resource name must be a string of length greater than 0 characters\"\n    );\n  }\n  const rootRefValue = typeof rootRef === \"string\" ? rootRef : rootRef();\n  const withSlashes = path.join(\"/\", rootRefValue, \"/\", relativePath, \"/\");\n  const slashCount = withSlashes.split(\"/\").length - 1;\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\"\n    not a \"collection\"e.g. /collection/document/ or\n    /collection/document/collection/document/`);\n  }\n  return withSlashes.slice(1, -1);\n}\n\nexport function joinPaths(...args: string[]) {\n  return path.join(...args);\n}\n","import {\n  IFirebaseWrapper,\n} from './IFirebaseWrapper';\n\nimport firebase from 'firebase/compat/app';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport 'firebase/compat/storage';\n\nimport { log } from 'misc';\nimport { RAFirebaseOptions } from 'providers/options';\nimport {\n  FireApp,\n  FireAuth,\n  FireAuthUserCredentials,\n  FireStorage,\n  FireStoragePutFileResult,\n  FireStore,\n  FireStoreBatch,\n  FireStoreCollectionRef,\n  FireUploadTaskSnapshot,\n  FireUser\n} from 'misc/firebase-models';\n\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private firestore: FireStore;\n  private app: FireApp;\n  public options: RAFirebaseOptions;\n\n  constructor(\n    inputOptions: RAFirebaseOptions | undefined,\n    firebaseConfig: {},\n  ) { \n    const optionsSafe = inputOptions || {};\n    this.options = optionsSafe;\n    this.app = (window as any)['_app'] = ObtainFirebaseApp(firebaseConfig, optionsSafe);\n    this.firestore = this.app.firestore();\n  }\n  dbGetCollection(absolutePath: string): FireStoreCollectionRef {\n    return this.firestore.collection(absolutePath);\n  }\n  dbCreateBatch(): FireStoreBatch {\n    return this.firestore.batch();\n  }\n  dbMakeNewId(): string {\n    return this.firestore.collection(\"collections\").doc().id\n  }\n\n  public OnUserLogout(callBack: (u: FireUser | null) => any) {\n    this.app.auth().onAuthStateChanged((user) => {\n      const isLoggedOut = !user;\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\n      if (isLoggedOut) {\n        callBack(user);\n      }\n    });\n  }\n  putFile(storagePath: string, rawFile: any): FireStoragePutFileResult {\n    const task = this.app.storage().ref(storagePath).put(rawFile);\n    const taskResult = new Promise<FireUploadTaskSnapshot>(\n      (res, rej) => task.then(res).catch(rej)\n    );\n    const downloadUrl = taskResult.then(t => t.ref.getDownloadURL()).then(url => url as string)\n    return {\n      task,\n      taskResult,\n      downloadUrl,\n    }\n  }\n  async getStorageDownloadUrl(fieldSrc: string): Promise<string> {\n    return this.app.storage().ref(fieldSrc).getDownloadURL();\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    return firebase.firestore.FieldValue.serverTimestamp();\n  }\n  async authSetPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    let persistenceResolved: string;\n    switch (persistenceInput) {\n      case 'local':\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\n        break;\n      case 'none':\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\n        break;\n      case 'session':\n      default:\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\n        break;\n    }\n    log('setPersistence', { persistenceInput, persistenceResolved });\n    return this.app.auth()\n      .setPersistence(persistenceResolved)\n      .catch((error) => console.error(error));\n  }\n  async authSigninEmailPassword(email: string, password: string): Promise<FireAuthUserCredentials> {\n    const user = await this.app.auth().signInWithEmailAndPassword(\n      email,\n      password\n    );\n    return user;\n  }\n  async authSignOut(): Promise<void> {\n    return this.app.auth().signOut();\n  }\n  async authGetUserLoggedIn(): Promise<FireUser> {\n    return new Promise((resolve, reject) => {\n      const auth = this.app.auth();\n      if (auth.currentUser) return resolve(auth.currentUser);\n      const unsubscribe = this.app.auth().onAuthStateChanged((user) => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n  public async GetUserLogin(): Promise<FireUser> {\n    return this.authGetUserLoggedIn();\n  }\n\n  /** @deprecated */\n  public auth(): FireAuth {\n    return this.app.auth();\n  }\n  /** @deprecated */\n  public storage(): FireStorage {\n    return this.app.storage();\n  }\n  /** @deprecated */\n  public GetApp(): FireApp {\n    return this.app;\n  }\n  /** @deprecated */\n  public db(): FireStore {\n    return this.firestore;\n  }\n}\n\nfunction ObtainFirebaseApp(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): firebase.app.App {\n  if (options.app) {\n    return options.app;\n  }\n  const isInitialized = !!firebase.apps?.length;\n  if (isInitialized) {\n    return firebase.app();\n  } else {\n    return firebase.initializeApp(firebaseConfig);\n  }\n}\n","import firebase from 'firebase/compat/app';\nimport 'firebase/compat/storage';\n\nexport type FireUser = firebase.User;\nexport type FireApp = firebase.app.App;\n\nexport type FireStorage = firebase.storage.Storage;\nexport type FireStorageReference = firebase.storage.Reference;\nexport type FireUploadTaskSnapshot = firebase.storage.UploadTaskSnapshot;\nexport type FireUploadTask = firebase.storage.UploadTask;\nexport type FireStoragePutFileResult = {\n  task: FireUploadTask, \n  taskResult: Promise<FireUploadTaskSnapshot>,\n  downloadUrl: Promise<string>,\n}\n\nexport type FireAuth = firebase.auth.Auth;\nexport type FireAuthUserCredentials = firebase.auth.UserCredential;\n\nexport type FireStore = firebase.firestore.Firestore;\nexport type FireStoreBatch = firebase.firestore.WriteBatch;\nexport type FireStoreTimeStamp = firebase.firestore.FieldValue;\nexport type FireStoreDocumentRef = firebase.firestore.DocumentReference;\nexport type FireStoreDocumentSnapshot = firebase.firestore.DocumentSnapshot<firebase.firestore.DocumentData>;\nexport type FireStoreCollectionRef = firebase.firestore.CollectionReference;\nexport type FireStoreQueryDocumentSnapshot = firebase.firestore.QueryDocumentSnapshot;\nexport type FireStoreQuery = firebase.firestore.Query;\nexport type FireStoreQueryOrder = firebase.firestore.OrderByDirection;\n\nexport const TASK_PAUSED = firebase.storage.TaskState.PAUSED\nexport const TASK_RUNNING = firebase.storage.TaskState.RUNNING\nexport const TASK_CANCELED = firebase.storage.TaskState.CANCELED\n","import { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\nimport {\n  log,\n  getAbsolutePath,\n  messageTypes,\n  logWarn,\n  IFirestoreLogger,\n  parseFireStoreDocument,\n} from '../../misc';\nimport { FireStoreCollectionRef } from 'misc/firebase-models';\n\ntype IResourceItem = {} & { id: string, deleted?: boolean };\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: FireStoreCollectionRef;\n  list: Array<IResourceItem>;\n}\n\nexport class ResourceManager {\n  private resources: Record<string, IResource> = {};\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions,\n    private flogger: IFirestoreLogger\n  ) {\n    this.fireWrapper.OnUserLogout(() => {\n      this.resources = {};\n    });\n  }\n\n  public async TryGetResource(\n    resourceName: string,\n    refresh?: 'REFRESH',\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log('resourceManager.TryGetResourcePromise', {\n      relativePath,\n      collectionQuery,\n    });\n    await this.initPath(relativePath);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType | undefined\n  ) {\n    if (this.options?.lazyLoading?.enabled) {\n      logWarn('resourceManager.RefreshResource', {\n        warn: 'RefreshResource is not available in lazy loading mode',\n      });\n      throw new Error(\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\n      );\n    }\n\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n\n    const collection = resource.collection;\n    const query = this.applyQuery(collection, collectionQuery);\n    const newDocs = await query.get();\n\n    resource.list = newDocs.docs.map((doc) => parseFireStoreDocument<IResourceItem>(doc));\n    const count = newDocs.docs.length;\n    this.flogger.logDocument(count)();\n    log('resourceManager.RefreshResource', {\n      newDocs,\n      resource,\n      collectionPath: collection.path,\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.GetResource(relativePath);\n    this.flogger.logDocument(1)();\n    const docSnap = await resource.collection.doc(docId).get();\n    if (!docSnap.exists) {\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\n    }\n    const result = parseFireStoreDocument(docSnap);\n    log('resourceManager.GetSingleDoc', {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result,\n    });\n    return result;\n  }\n\n  private async initPath(relativePath: string): Promise<void> {\n    const rootRef = this.options && this.options.rootRef;\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\n    const hasBeenInited = !!this.resources[relativePath];\n    log('resourceManager.initPath()', {\n      absolutePath,\n      hasBeenInited,\n    });\n    if (hasBeenInited) {\n      log('resourceManager.initPath() has been initialized already...');\n      return;\n    }\n    const collection = this.fireWrapper.dbGetCollection(absolutePath);\n    const list: Array<IResourceItem> = [];\n    const resource: IResource = {\n      collection,\n      list,\n      path: relativePath,\n      pathAbsolute: absolutePath,\n    };\n    this.resources[relativePath] = resource;\n    log('resourceManager.initPath() setting resource...', {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path,\n    });\n  }\n\n  public async getUserIdentifier(): Promise<string> {\n    const identifier = this.options.associateUsersById\n      ? await this.getCurrentUserId()\n      : await this.getCurrentUserEmail();\n    return identifier;\n  }\n\n  private async getCurrentUserEmail() {\n    const user = await this.fireWrapper.authGetUserLoggedIn();\n    if (user) {\n      return user.email as string;\n    } else {\n      return 'annonymous user';\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.fireWrapper.authGetUserLoggedIn();\n    if (user) {\n      return user.uid;\n    } else {\n      return 'annonymous user';\n    }\n  }\n\n  private applyQuery(\n    collection: FireStoreCollectionRef,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): FireStoreCollectionRef {\n    const collRef = collectionQuery ? collectionQuery(collection) : collection;\n\n    log('resourceManager.applyQuery() ...', {\n      collection,\n      collectionQuery: (collectionQuery || '-').toString(),\n      collRef,\n    });\n    return collRef;\n  }\n}\n","import { set, get } from \"lodash\";\nimport { TASK_CANCELED, TASK_PAUSED, TASK_RUNNING } from \"../../misc/firebase-models\";\nimport {\n  AddCreatedByFields,\n  AddUpdatedByFields,\n  IFirestoreLogger,\n  joinPaths,\n  log,\n  logError,\n  dispatch,\n  translateDocToFirestore,\n} from \"../../misc\";\nimport { RAFirebaseOptions } from \"../options\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { IResource, ResourceManager } from \"./ResourceManager\";\n\nexport class FireClient {\n  public rm: ResourceManager;\n\n  constructor(\n    public fireWrapper: IFirebaseWrapper,\n    public options: RAFirebaseOptions,\n    public flogger: IFirestoreLogger\n  ) {\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\n  }\n\n  public checkRemoveIdField(obj: any, docId: string) {\n    if (!this.options.dontAddIdFieldToDoc) {\n      obj.id = docId;\n    }\n  }\n\n  public transformToDb(resourceName: string, documentData: any, docId: string): any {\n    if (typeof this.options.transformToDb === 'function') {\n      return this.options.transformToDb(resourceName, documentData, docId);\n    }\n    return documentData;\n  }\n\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = r.collection.doc(id).path;\n\n    const result = translateDocToFirestore(data);\n    const uploads = result.uploads;\n    await Promise.all(\n      uploads.map(async (u) => {\n        const link = await this.uploadAndGetLink(\n          u.rawFile,\n          docPath,\n          u.fieldSlashesPath,\n          !!this.options.useFileNamesInStorage\n        );\n        set(data, u.fieldDotsPath + \".src\", link);\n      })\n    );\n    return data;\n  }\n\n  public async addCreatedByFields(obj: any) {\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  public async addUpdatedByFields(obj: any) {\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  private async uploadAndGetLink(\n    rawFile: any,\n    docPath: string,\n    fieldPath: string,\n    useFileName: boolean\n  ): Promise<string | undefined> {\n    const storagePath = useFileName\n      ? joinPaths(docPath, fieldPath, rawFile.name)\n      : joinPaths(docPath, fieldPath);\n    return this.saveFile(storagePath, rawFile);\n  }\n\n  private async saveFile(\n    storagePath: string,\n    rawFile: any\n  ): Promise<string | undefined> {\n    log(\"saveFile() saving file...\", { storagePath, rawFile });\n    try {\n      const { task, taskResult, downloadUrl } = this.fireWrapper.putFile(storagePath, rawFile);\n      const { name } = rawFile;\n      // monitor upload status & progress\n      dispatch('FILE_UPLOAD_WILL_START', name);\n      task.on('state_changed', (snapshot) => {\n        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n        log('Upload is ' + progress + '% done');\n        dispatch('FILE_UPLOAD_PROGRESS', name, progress);\n        switch (snapshot.state) {\n          case TASK_PAUSED:\n            log('Upload is paused');\n            dispatch('FILE_UPLOAD_PAUSED', name);\n            break;\n          case TASK_RUNNING:\n            log('Upload is running');\n            dispatch('FILE_UPLOAD_RUNNING', name);\n            break;\n          case TASK_CANCELED:\n            log('Upload has been canceled');\n            dispatch('FILE_UPLOAD_CANCELED', name);\n            break;\n          // case storage.TaskState.ERROR:\n            // already handled by catch\n          // case storage.TaskState.SUCCESS:\n            // already handled by then\n        }\n      });\n      const [getDownloadURL] = await Promise.all([\n        downloadUrl,\n        taskResult,\n      ]);\n      dispatch('FILE_UPLOAD_COMPLETE', name);\n      dispatch('FILE_SAVED', name);\n      log(\"saveFile() saved file\", {\n        storagePath,\n        taskResult,\n        getDownloadURL,\n      });\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\n    } catch (storageError) {\n      if (get(storageError, 'code') === \"storage/unknown\") {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError(\"saveFile() error saving file\", {\n          storageError,\n        });\n      }\n    }\n  }\n}\n","import { REF_INDENTIFIER } from \"./internal.models\";\n\ninterface ParsedUpload {\n  fieldDotsPath: string;\n  fieldSlashesPath: string;\n  rawFile: File | any;\n}\n\ninterface ParsedDocRef {\n  fieldDotsPath: string;\n  refPath: string;\n}\n\ninterface ParseResult {\n  parsedDoc: any;\n  uploads: ParsedUpload[];\n  refdocs: ParsedDocRef[];\n}\n\nexport function translateDocToFirestore(obj: any): ParseResult {\n  const isObject = !!obj && typeof obj === \"object\";\n  const result: ParseResult = {\n    uploads: [],\n    refdocs: [],\n    parsedDoc: {},\n  };\n  if (!isObject) {\n    return result;\n  }\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    recusivelyParseObjectValue(value, key, result);\n  });\n  result.parsedDoc = obj;\n  return result;\n}\n\nexport function recusivelyParseObjectValue(\n  input: any,\n  fieldPath: string,\n  result: ParseResult\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isRefField =\n    typeof fieldPath === \"string\" && fieldPath.includes(REF_INDENTIFIER);\n  if (isRefField) {\n    const refDocFullPath = input as string;\n    result.refdocs.push({\n      fieldDotsPath: fieldPath,\n      refPath: refDocFullPath,\n    });\n    return;\n  }\n  const isPrimitive = typeof input !== \"object\";\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === \"function\";\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map((value, index) =>\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, result)\n    );\n  }\n  const isFileField = !!input && input.hasOwnProperty(\"rawFile\");\n  if (isFileField) {\n    result.uploads.push({\n      fieldDotsPath: fieldPath,\n      fieldSlashesPath: fieldPath.split(\".\").join(\"/\"),\n      rawFile: input.rawFile,\n    });\n    delete input.rawFile;\n    return;\n  }\n  Object.keys(input).map((key) => {\n    const value = input[key];\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, result);\n  });\n  return input;\n}\n","import { RAFirebaseOptions } from \"index\";\nimport { IFirebaseWrapper, ResourceManager } from \"providers/database\";\n\nexport async function AddCreatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\n  options: Pick<\n    RAFirebaseOptions,\n    | \"associateUsersById\"\n    | \"disableMeta\"\n    | \"renameMetaFields\"\n    | \"metaFieldCasing\"\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const createAtSelector = GetSelectorsCreateAt(options);\n  const createBySelector = GetSelectorsCreateBy(options);\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\n  obj[createBySelector] = currentUserIdentifier;\n}\n\nexport async function AddUpdatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\n  options: Pick<\n    RAFirebaseOptions,\n    | \"associateUsersById\"\n    | \"disableMeta\"\n    | \"renameMetaFields\"\n    | \"metaFieldCasing\"\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const updateAtSelector = GetSelectorsUpdateAt(options);\n  const updateBySelector = GetSelectorsUpdateBy(options);\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\n  obj[updateBySelector] = currentUserIdentifier;\n}\n\nexport function GetSelectorsUpdateAt(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\n    return options.renameMetaFields.updated_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"lastupdate\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"lastUpdate\";\n  }\n  if (casing === \"snake\") {\n    return \"last_update\";\n  }\n  if (casing === \"pascal\") {\n    return \"LastUpdate\";\n  }\n  if (casing === \"kebab\") {\n    return \"last-update\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsUpdateBy(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\n    return options.renameMetaFields.updated_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"updatedby\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"updatedBy\";\n  }\n  if (casing === \"snake\") {\n    return \"updated_by\";\n  }\n  if (casing === \"pascal\") {\n    return \"UpdatedBy\";\n  }\n  if (casing === \"kebab\") {\n    return \"updated-by\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateAt(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\n    return options.renameMetaFields.created_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"createdate\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"createDate\";\n  }\n  if (casing === \"snake\") {\n    return \"create_date\";\n  }\n  if (casing === \"pascal\") {\n    return \"CreateDate\";\n  }\n  if (casing === \"kebab\") {\n    return \"create-date\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateBy(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\n    return options.renameMetaFields.created_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"createdby\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"createdBy\";\n  }\n  if (casing === \"snake\") {\n    return \"created_by\";\n  }\n  if (casing === \"pascal\") {\n    return \"CreatedBy\";\n  }\n  if (casing === \"kebab\") {\n    return \"created-by\";\n  }\n  return defautCase;\n}\n","import { FireStoreCollectionRef, FireStoreDocumentSnapshot, FireStoreQuery } from 'misc/firebase-models';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\n\nexport function setQueryCursor(\n  doc: FireStoreDocumentSnapshot,\n  params: messageTypes.IParamsGetList,\n  resourceName: string\n) {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  localStorage.setItem(key, doc.id);\n\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (!localCursorKeys) {\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\n  } else {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    const newCursors = cursors.concat(key);\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\n  }\n}\n\nexport async function getQueryCursor(\n  collection: FireStoreCollectionRef,\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<FireStoreDocumentSnapshot | false> {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  const docId = localStorage.getItem(key);\n  if (!docId) {\n    return false;\n  }\n\n  const doc = await collection.doc(docId).get();\n  flogger.logDocument(1)();\n  if (doc.exists) {\n    // incrementFirebaseReadsCounter(1);\n    return doc;\n  }\n  return false;\n}\n\nexport function clearQueryCursors(resourceName: string) {\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (localCursorKeys) {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\n    localStorage.removeItem(allCursorsKey);\n  }\n}\n\nexport async function findLastQueryCursor(\n  collection: FireStoreCollectionRef,\n  queryBase: FireStoreQuery,\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n) {\n  const { page, perPage } = params.pagination;\n\n  let lastQueryCursor: FireStoreDocumentSnapshot | false = false;\n  let currentPage = page - 1;\n\n  const currentPageParams = {\n    ...params,\n    pagination: {\n      ...params.pagination,\n    },\n  };\n  while (!lastQueryCursor && currentPage > 1) {\n    currentPage--;\n    currentPageParams.pagination.page = currentPage;\n    console.log('getting query cursor currentPage=', currentPage);\n    lastQueryCursor = await getQueryCursor(\n      collection,\n      currentPageParams,\n      resourceName,\n      flogger\n    );\n  }\n  const limit = (page - currentPage) * perPage;\n  const isFirst = currentPage === 1;\n\n  function getQuery() {\n    if (isFirst) {\n      return queryBase.limit(limit);\n    } else {\n      return queryBase.startAt(lastQueryCursor).limit(limit);\n    }\n  }\n\n  const newQuery = getQuery();\n  const snapshots = await newQuery.get();\n  const docsLength = snapshots.docs.length;\n  flogger.logDocument(docsLength)();\n  const lastDocIndex = docsLength - 1;\n  const lastDocRef = snapshots.docs[lastDocIndex];\n  return lastDocRef;\n}\n","import { FireStoreCollectionRef, FireStoreQuery, FireStoreQueryOrder } from 'misc/firebase-models';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\n\ninterface ParamsToQueryOptions {\n  filters?: boolean;\n  sort?: boolean;\n  pagination?: boolean;\n}\n\nconst defaultParamsToQueryOptions = {\n  filters: true,\n  sort: true,\n  pagination: true,\n};\n\nexport async function paramsToQuery<\n  TParams extends messageTypes.IParamsGetList\n>(\n  collection: FireStoreCollectionRef,\n  params: TParams,\n  resourceName: string,\n  flogger: IFirestoreLogger,\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\n): Promise<FireStoreQuery> {\n  const filtersStepQuery = options.filters\n    ? filtersToQuery(collection, params.filter)\n    : collection;\n\n  const sortStepQuery = options.sort\n    ? sortToQuery(filtersStepQuery, params.sort)\n    : filtersStepQuery;\n\n  return options.pagination\n    ? paginationToQuery(\n        sortStepQuery,\n        params,\n        collection,\n        resourceName,\n        flogger\n      )\n    : sortStepQuery;\n}\n\nexport function filtersToQuery(\n  query: FireStoreQuery,\n  filters: { [fieldName: string]: any }\n): FireStoreQuery {\n  const res = Object.entries(filters).reduce((acc,[fieldName, fieldValue]) => {\n    const opStr = fieldValue && Array.isArray(fieldValue) ? 'in' : '==';\n    return acc.where(fieldName, opStr, fieldValue);\n  }, query);\n  return res;\n}\n\nexport function sortToQuery(\n  query: FireStoreQuery,\n  sort: { field: string; order: string }\n): FireStoreQuery {\n  if (sort != null && sort.field !== 'id') {\n    const { field, order } = sort;\n    const parsedOrder = order.toLocaleLowerCase() as FireStoreQueryOrder;\n    return query.orderBy(field, parsedOrder);\n  }\n  return query;\n}\n\nasync function paginationToQuery<TParams extends messageTypes.IParamsGetList>(\n  query: FireStoreQuery,\n  params: TParams,\n  collection: FireStoreCollectionRef,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<FireStoreQuery> {\n  const { page, perPage } = params.pagination;\n  if (page === 1) {\n    query = query.limit(perPage);\n  } else {\n    let queryCursor = await getQueryCursor(\n      collection,\n      params,\n      resourceName,\n      flogger\n    );\n    if (!queryCursor) {\n      queryCursor = await findLastQueryCursor(\n        collection,\n        query,\n        params,\n        resourceName,\n        flogger\n      );\n    }\n    query = query.startAfter(queryCursor).limit(perPage);\n  }\n\n  return query;\n}\n\nexport function getFullParamsForQuery<\n  TParams extends messageTypes.IParamsGetList\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\n  return {\n    ...reactAdminParams,\n    filter: softdeleteEnabled\n      ? {\n          deleted: false,\n          ...reactAdminParams.filter,\n        }\n      : reactAdminParams.filter,\n  };\n}\n\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\n  params: TParams\n): TParams {\n  return {\n    ...params,\n    pagination: {\n      ...params.pagination,\n      page: params.pagination.page + 1,\n    },\n  };\n}\n","import {\n  log,\n  messageTypes,\n  parseFireStoreDocument,\n  recursivelyMapStorageUrls,\n} from '../../misc';\nimport { IResource, ResourceManager } from '../database/ResourceManager';\nimport { RAFirebaseOptions } from '../options';\nimport * as ra from '../../misc/react-admin-models';\nimport {\n  getFullParamsForQuery,\n  getNextPageParams,\n  paramsToQuery,\n} from './paramsToQuery';\nimport { clearQueryCursors, setQueryCursor } from './queryCursors';\nimport { FireClient } from 'providers/database';\nimport { FireStoreCollectionRef, FireStoreDocumentSnapshot } from 'misc/firebase-models';\n\nexport class FirebaseLazyLoadingClient {\n  constructor(\n    private readonly options: RAFirebaseOptions,\n    private readonly rm: ResourceManager,\n    private client: FireClient\n  ) {}\n\n  public async apiGetList<T extends ra.Record>(\n    resourceName: string,\n    reactAdminParams: ra.GetListParams\n  ): Promise<ra.GetListResult<T>> {\n    const r = await this.tryGetResource(resourceName);\n    const params = getFullParamsForQuery(\n      reactAdminParams,\n      !!this.options.softDelete\n    );\n\n    log('apiGetListLazy', { resourceName, params });\n\n    const query = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await query.get();\n\n    const resultsCount = snapshots.docs.length;\n    if (!resultsCount) {\n      log('apiGetListLazy', {\n        message: 'There are not records for given query',\n      });\n      return { data: [], total: 0 };\n    }\n    this.client.flogger.logDocument(resultsCount)();\n\n    const data = snapshots.docs.map(doc => parseFireStoreDocument<T>(doc));\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\n    // After fetching documents save queryCursor for next page\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\n    // Hardcoded to allow next pages, as we don't have total number of items\n    let total = 9000;\n\n    // Check for next pages\n    // If it's last page, we can count all items and disable going to next page\n    const isOnLastPage = await this.checkIfOnLastPage(\n      r.collection,\n      params,\n      resourceName,\n      nextPageCursor\n    );\n\n    if (isOnLastPage) {\n      const { page, perPage } = params.pagination;\n      total = (page - 1) * perPage + data.length;\n      log('apiGetListLazy', { message: \"It's last page of collection.\" });\n    }\n\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetListLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total,\n      };\n    }\n\n    log('apiGetListLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n\n    return { data, total };\n  }\n\n  public async apiGetManyReference(\n    resourceName: string,\n    reactAdminParams: messageTypes.IParamsGetManyReference\n  ): Promise<messageTypes.IResponseGetManyReference> {\n    const r = await this.tryGetResource(resourceName);\n    log('apiGetManyReferenceLazy', {\n      resourceName,\n      resource: r,\n      reactAdminParams,\n    });\n    const filterWithTarget = {\n      ...reactAdminParams.filter,\n      [reactAdminParams.target]: reactAdminParams.id,\n    };\n    const params = getFullParamsForQuery(\n      {\n        ...reactAdminParams,\n        filter: filterWithTarget,\n      },\n      !!this.options.softDelete\n    );\n\n    const query = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await query.get();\n    const resultsCount = snapshots.docs.length;\n    this.client.flogger.logDocument(resultsCount)();\n    const data = snapshots.docs.map(d => parseFireStoreDocument(d));\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetManyReferenceLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total: data.length,\n      };\n    }\n\n    log('apiGetManyReferenceLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n    return { data, total: data.length };\n  }\n\n  private async checkIfOnLastPage<TParams extends messageTypes.IParamsGetList>(\n    collection: FireStoreCollectionRef,\n    params: TParams,\n    resourceName: string,\n    nextPageCursor: FireStoreDocumentSnapshot,\n  ): Promise<boolean> {\n    const query = await paramsToQuery(\n      collection,\n      params,\n      resourceName,\n      this.client.flogger,\n      {\n        filters: true,\n        sort: true,\n      }\n    );\n    if (!nextPageCursor) {\n      throw new Error('Page cursor was empty...');\n    }\n    const nextElementSnapshot = await query\n      .startAfter(nextPageCursor)\n      .limit(1)\n      .get();\n\n    if (!nextElementSnapshot.empty) {\n      // this.incrementFirebaseReadsCounter(1);\n    }\n\n    return nextElementSnapshot.empty;\n  }\n\n  public clearQueryCursors(resourceName: string) {\n    clearQueryCursors(resourceName);\n  }\n\n  private async tryGetResource(\n    resourceName: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n}\n","import {\n  getAbsolutePath,\n  log,\n  logger,\n  retrieveStatusCode,\n  logError,\n  MakeFirestoreLogger,\n} from \"../misc\";\nimport * as ra from \"../misc/react-admin-models\";\nimport { RAFirebaseOptions } from \"./options\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\nimport { FireApp } from \"../misc/firebase-models\";\nimport { FireClient } from \"./database/FireClient\";\nimport { GetList, GetMany, GetManyReference, GetOne } from \"./queries\";\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from \"./commands\";\n\nexport interface IDataProvider extends ra.DataProvider {\n  app: FireApp;\n}\n\nexport function DataProvider(\n  firebaseConfig: {},\n  optionsInput?: RAFirebaseOptions\n): IDataProvider {\n  const options = optionsInput || {};\n  verifyDataProviderArgs(firebaseConfig, options);\n\n  const flogger = MakeFirestoreLogger(options);\n  logger.SetEnabled(!!options?.logging);\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\n  log('Creating FirebaseDataProvider', {\n    firebaseConfig,\n    options\n  });\n\n  const fireWrapper = new FirebaseWrapper(optionsInput, firebaseConfig);\n\n  async function run<T>(cb: () => Promise<T>) {\n    let res: any;\n    try {\n      res = await cb();\n      return res;\n    } catch (error) {\n      const errorMsg = ((error as any) || '').toString();\n      const code = retrieveStatusCode(errorMsg);\n      const errorObj = { status: code, message: errorMsg, json: res };\n      logError(\"DataProvider:\", error, { errorMsg, code, errorObj });\n      throw errorObj;\n    }\n  }\n  const client = new FireClient(fireWrapper, options, flogger);\n\n  const newProviderApi: IDataProvider = {\n    app: fireWrapper.GetApp(),\n    getList<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetListParams\n    ): Promise<ra.GetListResult<RecordType>> {\n      return run(() => GetList<RecordType>(resource, params, client));\n    },\n    getOne<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetOneParams\n    ): Promise<ra.GetOneResult<RecordType>> {\n      return run(() => GetOne<RecordType>(resource, params, client));\n    },\n    getMany<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyParams\n    ): Promise<ra.GetManyResult<RecordType>> {\n      return run(() => GetMany<RecordType>(resource, params, client));\n    },\n    getManyReference<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyReferenceParams\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\n      return run(() =>\n        GetManyReference<RecordType>(resource, params, client)\n      );\n    },\n    update<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.UpdateParams\n    ): Promise<ra.UpdateResult<RecordType>> {\n      return run(() => Update<RecordType>(resource, params, client));\n    },\n    updateMany(\n      resource: string,\n      params: ra.UpdateManyParams\n    ): Promise<ra.UpdateManyResult> {\n      return run(() => UpdateMany(resource, params, client));\n    },\n    create<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.CreateParams\n    ): Promise<ra.CreateResult<RecordType>> {\n      return run(() => Create<RecordType>(resource, params, client));\n    },\n    delete<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.DeleteParams\n    ): Promise<ra.DeleteResult<RecordType>> {\n      return run(() => Delete(resource, params, client));\n    },\n    deleteMany(\n      resource: string,\n      params: ra.DeleteManyParams\n    ): Promise<ra.DeleteManyResult> {\n      return run(() => DeleteMany(resource, params, client));\n    },\n  };\n\n  return newProviderApi;\n}\n\nfunction verifyDataProviderArgs(\n  firebaseConfig: {},\n  options?: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n  if (options && options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, 'test');\n  }\n}\n","// From firebase SDK\n\nimport { logError } from \"./logger\";\n\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\n  // Make sure any successful status is OK.\n  if (status >= 200 && status < 300) {\n    return 'ok';\n  }\n  switch (status) {\n    case 401: // 'unauthenticated'\n    case 403: // 'permission-denied'\n      return 'unauthenticated';\n\n    case 0: // 'internal'\n    case 400: // 'invalid-argument'\n    case 404: // 'not-found'\n    case 409: // 'aborted'\n    case 429: // 'resource-exhausted'\n    case 499: // 'cancelled'\n    case 500: // 'internal'\n    case 501: // 'unimplemented'\n    case 503: // 'unavailable'\n    case 504: // 'deadline-exceeded'\n    default:\n      // ignore\n      return 'ok';\n  }\n}\n\n// From firebase SDK\n// tslint:disable-next-line:max-line-length\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusCode(statusTxt: string): number {\n  // Make sure any successful status is OK.\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\n  const status = Array.isArray(regexResult) && regexResult[1];\n  if (!status) {\n    logError('unknown StatusCode ', {statusTxt});\n  }\n  switch (status) {\n    case 'unauthenticated':\n      return 401;\n    case 'permission-denied':\n      return 403;\n    case 'internal':\n      return 0;\n    case 'invalid-argument':\n      return 400;\n    case 'not-found':\n      return 404;\n    case 'aborted':\n      return 409;\n    case 'resource-exhausted':\n      return 429;\n    case 'cancelled':\n      return 499;\n    case 'internal':\n      return 500;\n    case 'unimplemented':\n      return 501;\n    case 'unavailable':\n      return 503;\n    case 'deadline-exceeded':\n      return 504;\n    default:\n      return 200;\n  }\n}\n","import { FireClient } from '../database/FireClient';\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\nimport {\n  filterArray,\n  log,\n  recursivelyMapStorageUrls,\n  sortArray,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\n\nexport async function GetList<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetListParams,\n  client: FireClient\n): Promise<ra.GetListResult<T>> {\n  log('GetList', { resourceName, params });\n  const { rm, fireWrapper, options } = client;\n\n  if (options?.lazyLoading?.enabled) {\n    const lazyClient = new FirebaseLazyLoadingClient(\n      options,\n      rm,\n      client\n    );\n    return lazyClient.apiGetList<T>(resourceName, params);\n  }\n\n  const filterSafe = params.filter || {};\n\n  const collectionQuery = filterSafe.collectionQuery;\n  delete filterSafe.collectionQuery;\n\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\n  const data = r.list;\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === 'ASC') {\n      sortArray(data, field, 'asc');\n    } else {\n      sortArray(data, field, 'desc');\n    }\n  }\n  let softDeleted = data;\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\n    softDeleted = data.filter((doc) => !doc.deleted);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\n  const total = filteredData.length;\n\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data,\n      total,\n    };\n  }\n\n  return {\n    data: dataPage,\n    total,\n  };\n}\n","import { FireClient } from '../database/FireClient';\nimport { log, translateDocFromFirestore } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\n\nexport async function GetOne<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetOneParams,\n  client: FireClient\n): Promise<ra.GetOneResult<T>> {\n  log(\"GetOne\", { resourceName, params });\n  const { rm } = client;\n  try {\n    const id = params.id + '';\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\n    client.flogger.logDocument(1)();\n    return { data: dataSingle as T };\n  } catch (error) {\n    throw new Error(\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\n    );\n  }\n}\n","import { FireClient } from '../database/FireClient';\nimport { log, recursivelyMapStorageUrls } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\n\nexport async function GetMany<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyParams,\n  client: FireClient\n): Promise<ra.GetManyResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  const ids = params.ids;\n  log(\"GetMany\", { resourceName, resource: r, params, ids });\n  const matchDocSnaps = await Promise.all(\n    ids.map(idObj => {\n      if (typeof idObj === 'string') {\n        return r.collection.doc(idObj).get()\n      }\n      // Will get and resolve reference documents into the current doc\n      return r.collection.doc((idObj as any)['___refid']).get()\n    })\n  );\n  client.flogger.logDocument(ids.length)();\n  const matches = matchDocSnaps.map((snap) => {\n    return { ...snap.data(), id: snap.id } as T;\n  });\n  const permittedData = options.softDelete\n    ? matches.filter((row) => !row['deleted'])\n    : matches;\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data,\n    };\n  }\n\n  return {\n    data: permittedData,\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { filterArray, log, recursivelyMapStorageUrls, sortArray } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function GetManyReference<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyReferenceParams,\n  client: FireClient\n): Promise<ra.GetManyReferenceResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  log(\"GetManyReference\", { resourceName, params });\n  const filterSafe = params.filter || {};\n  const collectionQuery = filterSafe.collectionQuery;\n  const r = await rm.TryGetResource(\n    resourceName,\n    \"REFRESH\",\n    collectionQuery\n  );\n  delete filterSafe.collectionQuery;\n  log(\"apiGetManyReference\", { resourceName, resource: r, params });\n  const data = r.list;\n  const targetField = params.target;\n  const targetValue = params.id;\n  let softDeleted = data;\n  if (options.softDelete) {\n    softDeleted = data.filter(doc => !doc['deleted'])\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const targetIdFilter: Record<string, ra.Identifier> = {};\n  targetIdFilter[targetField] = targetValue;\n  const permittedData = filterArray(filteredData, targetIdFilter);\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === \"ASC\") {\n      sortArray(permittedData, field, \"asc\");\n    } else {\n      sortArray(permittedData, field, \"desc\");\n    }\n  }\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\n  const total = permittedData.length;\n\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((doc) =>\n        recursivelyMapStorageUrls(fireWrapper, doc)\n      )\n    );\n    return { data, total };\n  }\n\n  return { data: dataPage, total };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function Update<T extends ra.Record>(\n  resourceName: string,\n  params: ra.UpdateParams,\n  client: FireClient\n): Promise<ra.UpdateResult<T>> {\n  const { rm } = client;\n  log(\"Update\", { resourceName, params });\n  const id = params.id + \"\";\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"Update\", { resourceName, resource: r, params });\n  const data = await client.parseDataAndUpload(r, id, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, id);\n  await client.addUpdatedByFields(docObj);\n  const docObjTransformed = client.transformToDb(resourceName, docObj, id);\n  await r.collection.doc(id).update(docObjTransformed);\n  return {\n    data: {\n      ...data,\n      id: id,\n    },\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function UpdateMany(\n  resourceName: string,\n  params: ra.UpdateManyParams,\n  client: FireClient\n): Promise<ra.UpdateManyResult> {\n  const { rm } = client;\n  log(\"UpdateMany\", { resourceName, params });\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"UpdateMany\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async id => {\n      const idStr = id+'';\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\n      const docObj = { ...data };\n      client.checkRemoveIdField(docObj, idStr);\n      await client.addUpdatedByFields(docObj);\n      const docObjTransformed = client.transformToDb(resourceName, docObj, idStr);\n      await r.collection\n        .doc(idStr)\n        .update(docObjTransformed);\n      return {\n        ...data,\n        id: idStr\n      };\n    })\n  );\n  return {\n    data: returnData\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function Create<T extends ra.Record>(\n  resourceName: string,\n  params: ra.CreateParams,\n  client: FireClient\n): Promise<ra.CreateResult<T>> {\n  const { rm, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"Create\", { resourceName, resource: r, params });\n  const hasOverridenDocId = params.data && params.data.id;\n  log(\"Create\", { hasOverridenDocId });\n  if (hasOverridenDocId) {\n    const overridenId = params.data.id;\n    const exists = (await r.collection.doc(overridenId).get()).exists;\n    if (exists) {\n      throw new Error(\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n      );\n    }\n    const data = await client.parseDataAndUpload(r, overridenId, params.data);\n    if (!overridenId) {\n      throw new Error(\"id must be a valid string\");\n    }\n    const docObj = { ...data };\n    client.checkRemoveIdField(docObj, overridenId);\n    await client.addCreatedByFields(docObj);\n    await client.addUpdatedByFields(docObj);\n    const docObjTransformed = client.transformToDb(resourceName, docObj, overridenId);\n    log(\"Create\", { docObj });\n    await r.collection.doc(overridenId).set(docObjTransformed, { merge: false });\n    return {\n      data: {\n        ...docObjTransformed,\n        id: overridenId,\n      },\n    };\n  }\n  const newId = fireWrapper.dbMakeNewId();\n  const data = await client.parseDataAndUpload(r, newId, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, newId);\n  await client.addCreatedByFields(docObj);\n  await client.addUpdatedByFields(docObj);\n  const docObjTransformed = client.transformToDb(resourceName, docObj, newId);\n  await r.collection.doc(newId).set(docObjTransformed, { merge: false });\n  return {\n    data: {\n      ...docObjTransformed,\n      id: newId,\n    },\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\nimport { DeleteSoft } from \"./Delete.Soft\";\n\nexport async function Delete<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm, options } = client;\n  if (options.softDelete) {\n    return DeleteSoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log(\"apiDelete\", { resourceName, resource: r, params });\n  try {\n    const id = params.id + \"\";\n    await r.collection.doc(id).delete();\n  } catch (error) {\n    throw new Error(error as any);\n  }\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log, logError } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function DeleteSoft<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm } = client;\n  const id = params.id + \"\";\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteSoft\", { resourceName, resource: r, params });\n  const docObj = { deleted: true };\n  await client.addUpdatedByFields(docObj);\n  r.collection\n    .doc(id)\n    .update(docObj)\n    .catch((error) => {\n      logError(\"DeleteSoft error\", { error });\n    });\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\nimport { DeleteManySoft } from \"./DeleteMany.Soft\";\n\nexport async function DeleteMany(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { options, rm, fireWrapper } = client;\n  if (options.softDelete) {\n    return DeleteManySoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteMany\", { resourceName, resource: r, params });\n  const returnData: ra.Identifier[] = [];\n  const batch = fireWrapper.dbCreateBatch();\n  for (const id of params.ids) {\n    const idStr = id + '';\n    const docToDelete = r.collection.doc(idStr);\n    batch.delete(docToDelete);\n    returnData.push(id);\n  }\n  try {\n    await batch.commit();\n  } catch (error) {\n    throw new Error(error as any)\n  }\n  return { data: returnData };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log, logError } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function DeleteManySoft(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { rm } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteManySoft\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + \"\";\n      const docObj = { deleted: true };\n      await client.addUpdatedByFields(docObj);\n      r.collection\n        .doc(idStr)\n        .update(docObj)\n        .catch((error) => {\n          logError(\"apiSoftDeleteMany error\", { error });\n        });\n      return idStr;\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n","import { messageTypes } from './../misc/messageTypes';\nimport { log, retrieveStatusTxt, logWarn, logger } from '../misc';\nimport { RAFirebaseOptions } from './options';\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\nimport {\n  AuthProvider as RaAuthProvider,\n  UserIdentity,\n} from '../misc/react-admin-models';\nimport { IFirebaseWrapper } from './database';\nimport { FireUser } from '../misc/firebase-models';\n\nclass AuthClient {\n  private fireWrapper: IFirebaseWrapper;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log('Auth Client: initializing...', { firebaseConfig, options });\n    this.fireWrapper = new FirebaseWrapper(options, firebaseConfig);\n    options.persistence && this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    return this.fireWrapper.authSetPersistence(persistenceInput);\n  }\n\n  public async HandleAuthLogin(params: { username: string; password: string }) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.fireWrapper.authSigninEmailPassword(\n          username,\n          password\n        );\n        log('HandleAuthLogin: user sucessfully logged in', { user });\n        return user;\n      } catch (e) {\n        log('HandleAuthLogin: invalid credentials', { params });\n        throw new Error('Login error: invalid credentials');\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.fireWrapper.authSignOut();\n  }\n\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\n    const status = !!errorHttp && errorHttp.status;\n    const statusTxt = retrieveStatusTxt(status);\n    if (statusTxt === 'ok') {\n      log('API is actually authenticated');\n      return Promise.resolve();\n    }\n    logWarn('Recieved authentication error from API');\n    return Promise.reject();\n  }\n\n  public async HandleAuthCheck(): Promise<any> {\n    return this.getUserLogin();\n  }\n\n  public getUserLogin(): Promise<FireUser> {\n    return this.fireWrapper.authGetUserLoggedIn();\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetIdentity(): Promise<UserIdentity> {\n    try {\n      const { uid, displayName, photoURL } = await this.getUserLogin();\n      const identity: UserIdentity = {\n        id: uid,\n        fullName: `${displayName ?? ''}`,\n        avatar: `${photoURL ?? ''}`,\n      };\n      return identity;\n    } catch (e) {\n      log('HandleGetIdentity: no user is logged in', {\n        e,\n      });\n      return null as any;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log(\n        'HandleGetJWTToken: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): ReactAdminFirebaseAuthProvider {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  logger.SetEnabled(!!options?.logging);\n  const auth = new AuthClient(firebaseConfig, options);\n\n  const provider: ReactAdminFirebaseAuthProvider = {\n    // React Admin Interface\n    login: (params) => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: (error) => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getIdentity: () => auth.HandleGetIdentity(),\n    // Custom Functions\n    getAuthUser: () => auth.getUserLogin(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken(),\n  };\n  return provider;\n}\n\nexport type ReactAdminFirebaseAuthProvider = RaAuthProvider & {\n  // Custom Functions\n  getAuthUser: () => Promise<FireUser>,\n  getJWTAuthTime: () => Promise<string | null>,\n  getJWTExpirationTime: () => Promise<string | null>,\n  getJWTSignInProvider: () => Promise<string | null>,\n  getJWTClaims: () => Promise<{ [key: string]: any; } | null>,\n  getJWTToken: () => Promise<string | null>,  \n}\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n}\n"],"names":["sortArray","data","field","dir","sort","a","b","rawA","get","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","value","searchField","searchValue","tree","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","objectFlatten","getFieldReferences","filter","row","reduce","acc","cur","searchThis","toString","includes","isArray","doesRowMatch","LogNoOp","args","LoggerBase","constructor","title","cacheEnabledKey","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","log","console","bind","warn","error","logger","logError","logWarn","KEY_SINGLE","dispatch","eventName","fileName","eventMonitor","document","getElementById","event","CustomEvent","detail","dispatchEvent","isInputADocReference","input","id","firestore","parent","recursivelyMapStorageUrls","async","fireWrapper","fieldValue","has","src","storage","ref","getDownloadURL","Promise","all","index","parseFireStoreDocument","doc","result","parsedDoc","refdocs","recusivelyCheckObjectValue","fieldPath","toDate","refDocPath","translateDocFromFirestore","dataWithRefs","refDocs","d","set","applyRefDocs","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","length","slice","joinPaths","FirebaseWrapper","inputOptions","firebaseConfig","optionsSafe","options","app","window","firebase","apps","_firebase$apps","initializeApp","ObtainFirebaseApp","dbGetCollection","absolutePath","collection","dbCreateBatch","batch","dbMakeNewId","OnUserLogout","callBack","auth","onAuthStateChanged","user","isLoggedOut","putFile","storagePath","rawFile","task","put","taskResult","res","rej","then","catch","downloadUrl","t","url","[object Object]","fieldSrc","serverTimestamp","FieldValue","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","setPersistence","email","password","signInWithEmailAndPassword","signOut","resolve","reject","currentUser","unsubscribe","authGetUserLoggedIn","GetApp","db","TASK_PAUSED","TaskState","PAUSED","TASK_RUNNING","RUNNING","TASK_CANCELED","CANCELED","ResourceManager","flogger","resources","resourceName","refresh","collectionQuery","RefreshResource","TryGetResourcePromise","GetResource","resource","initPath","_this$options","lazyLoading","_this$options$lazyLoa","enabled","query","applyQuery","newDocs","list","docs","logDocument","collectionPath","docId","docSnap","exists","hasBeenInited","pathAbsolute","allResources","associateUsersById","getCurrentUserId","getCurrentUserEmail","uid","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","transformToDb","documentData","r","docPath","uploads","recusivelyParseObjectValue","fieldDotsPath","refPath","fieldSlashesPath","translateDocToFirestore","u","link","_this","uploadAndGetLink","useFileNamesInStorage","disableMeta","currentUserIdentifier","getUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","updateAtSelector","updated_at","GetSelectorsUpdateAt","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","useFileName","name","saveFile","on","snapshot","progress","bytesTransferred","totalBytes","state","relativeFilePaths","storageError","getQueryCursor","params","btoa","JSON","stringify","defaultParamsToQueryOptions","filters","pagination","paramsToQuery","filtersStepQuery","entries","opStr","where","sortStepQuery","order","parsedOrder","toLocaleLowerCase","orderBy","sortToQuery","page","perPage","limit","queryCursor","queryBase","lastQueryCursor","currentPage","currentPageParams","newQuery","startAt","snapshots","docsLength","findLastQueryCursor","startAfter","paginationToQuery","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","FirebaseLazyLoadingClient","client","tryGetResource","softDelete","resultsCount","message","total","nextPageCursor","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","checkIfOnLastPage","parsedData","filterWithTarget","target","_this2","empty","clearQueryCursors","forEach","cursor","DataProvider","optionsInput","verifyDataProviderArgs","ResetCount","shouldReset","docCount","_options$lazyLoading","count","incrementBy","currentCountRaw","incremented","parseInt","incrementRead","MakeFirestoreLogger","logging","firestoreCostsLogger","_options$firestoreCos","_options$firestoreCos2","persistCount","run","cb","errorMsg","code","statusTxt","regexResult","exec","status","retrieveStatusCode","errorObj","json","getList","apiGetList","filterSafe","TryGetResource","softDeleted","filteredData","pageStart","dataPage","GetList","getOne","dataSingle","GetSingleDoc","GetOne","getMany","ids","matchDocSnaps","idObj","matches","snap","permittedData","GetMany","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","parseDataAndUpload","docObj","addUpdatedByFields","docObjTransformed","Update","updateMany","idStr","UpdateMany","create","hasOverridenDocId","overridenId","addCreatedByFields","merge","newId","Create","delete","previousData","DeleteSoft","Delete","deleteMany","DeleteManySoft","returnData","docToDelete","commit","DeleteMany","AuthClient","persistence","authSetPersistence","username","getUserLogin","authSigninEmailPassword","e","HandleAuthLogout","authSignOut","HandleAuthError","errorHttp","retrieveStatusTxt","getIdTokenResult","claims","displayName","photoURL","fullName","avatar","authTime","expirationTime","signInProvider","issuedAtTime","token","AuthProvider","VerifyAuthProviderArgs","login","HandleAuthLogin","logout","checkAuth","HandleAuthCheck","checkError","getPermissions","HandleGetPermissions","getIdentity","HandleGetIdentity","getAuthUser","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken"],"mappings":"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"}